<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pannellum with ML</title>
    <script src="https://cdn.pannellum.org/2.5/pannellum.js"></script>
    <link rel="stylesheet" href="https://cdn.pannellum.org/2.5/pannellum.css" />
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <style>
      body,
      html {
        height: 100%;
        margin: 0;
        overflow: hidden;
      }

      #panorama {
        width: 100%;
        height: 60vh;
      }

      #tileCanvas {
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="panorama"></div>
    <canvas id="tileCanvas" style="width: 512px; height: 512px"></canvas>
    
    <script>
      async function loadModel() {
        try {
          const model = await tf.loadLayersModel("./model.json");
          return model;
        } catch (error) {
          console.error("Error loading the model:", error);
          throw error;
        }
      }

      function preprocess(imageData) {
        return tf.tidy(() => {
          const tensor = tf.browser.fromPixels(imageData).toFloat();
          // Resize the image to match the expected model input dimensions
          const resized = tf.image.resizeBilinear(tensor, [224, 224]);
          // Normalize pixel values to be between 0 and 1
          const normalized = resized.div(tf.scalar(255));
          // Add a batch dimension
          const batched = normalized.expandDims(0);
          return batched;
        });
      }

      function postprocess(predictions) {

        // Implement postprocessing steps if needed
        return predictions;
      }

      function createHotspot(pitch, yaw, results) {
        return {
          pitch: pitch,
          yaw: yaw,
          cssClass: "custom-hotspot",
          createTooltipFunc: hotspot,
          createTooltipArgs: results,  
        };
      }
      
      async function displayResults(
        results,
        tileX,
        tileY,
        tileWidth,
        tileHeight,
        pitch,
        yaw
      ) {
        // const hotspotsData = JSON.parse(localStorage.getItem('panoramaHotspots')) || [];

        // Add the current pitch, yaw, and text to the hotspotsData array
        const hotspot = createHotspot(pitch, yaw, results);
        // hotspotsData.push(hotspot);
        await viewer.addHotSpot(hotspot)
        console.log(viewer.getConfig().hotSpots);
        // Update localStorage with the new hotspotsData
        // localStorage.setItem('panoramaHotspots', JSON.stringify(hotspotsData));
        
        // Assuming viewer is already defined
      }
      const currhotspotsData = JSON.parse(localStorage.getItem('panoramaHotspots')) || [];
      console.log(currhotspotsData);
      const viewer = pannellum.viewer("panorama", {
        type: "equirectangular",
        panorama: "./sunflower.jpeg",
        tileSize: 512,
        tileResolution: 100,
        autoload: true,
        showZoomCtrl: false,
        autoZoom: false,
        compass: false,
        navbar: true,
        hfov: 100,
        vfov: 60,
        hotSpots: currhotspotsData,
      });
        function getPredictedClass(predictions) {
          const predictedClassIndex = predictions.argMax(1).dataSync()[0];
          return predictedClassIndex;
        }
        const classNames = ["Water Lily", "Tulip", "SunFlower", "Rose","Magnolia","Iris","Dandelion","Daffodil","Coreopsis","Common Daisy","Carnation","California Puppy","Calendula","BlackEyed-Susan","BellFlower","Astible"];

        function getPredictedClassName(predictedClassIndex) {
          return classNames[predictedClassIndex];
        }

      async function processTile(tileX,tileY,tileWidth,tileHeight,pitch,yaw) {
        try {
          const img = new Image();
          img.onerror = function () {
            console.error("Error loading the image:", img.src);
          };
          img.onload = async function () {
            console.log("Image Loaded");

            const tileCanvas = document.getElementById("tileCanvas");
            const tileCtx = tileCanvas.getContext("2d");

            tileCtx.clearRect(0, 0, tileCanvas.width, tileCanvas.height);

            // Display the clipped area of the tile on the canvas for visualization
            tileCtx.drawImage(
              img,
              tileX,
              tileY,
              tileWidth,
              tileHeight,
              0,
              0,
              1000,
              1000
            );

            // Display the canvas for visualization
            tileCanvas.style.display = "block";

            // Get image data for the clipped area
            const tileImageData = await tileCtx.getImageData(
              0,
              0,
              tileCanvas.width,
              tileCanvas.height
            );
            console.log(tileImageData);
            // Preprocess the tile image data

            // const preprocessedData = tf.tensor4d(tileImageData, [1, 150, 300, 3]);
            const preprocessedData = preprocess(tileImageData);

            // Load the ML model
            const model = await loadModel();
            console.log("Preprocessed Data" + preprocessedData);

            // Make predictions using the ML model
            const predictions = await model.predict(preprocessedData);
            console.log("Predictions " + predictions);

            const predictedClassIndex = getPredictedClass(predictions)
            console.log(predictedClassIndex);

            const predictedClass = getPredictedClassName(predictedClassIndex);
            console.log(predictedClass);
            // Postprocess the predictions if needed
            const postprocessedResults = postprocess(predictions);
            
            // Hide the canvas after processing
            // tileCanvas.style.display = "none";
            console.log(postprocessedResults);

            // Display the results on the panoramic view
            displayResults(
              predictedClass,
              tileX,
              tileY,
              tileWidth,
              tileHeight,
              pitch,
              yaw
            );
          };

          // Replace with the actual path to your panoramic image
          img.src = "./sunflower.jpeg";
        } catch (error) {
          console.error("Error processing the tile:", error);
        }
      }

      function hotspot(hotSpotDiv, args) {
        hotSpotDiv.classList.add("custom-tooltip");
        var span = document.createElement("span");
        span.innerHTML = args;
        hotSpotDiv.appendChild(span);
        span.style.width = span.scrollWidth - 20 + "px";
        span.style.marginLeft =
          -(span.scrollWidth - hotSpotDiv.offsetWidth) / 2 + "px";
        span.style.marginTop = -span.scrollHeight - 12 + "px";
      }

      function pitchYawToImageCoordinates(pitch, yaw) {
        // Get the internal renderer
        const renderer = viewer.getRenderer();

        // Get the current panorama dimensions
        const panoramaWidth = 265;
        const panoramaHeight = 148;

        // Normalize pitch and yaw to the range [0, 360]
        const normalizedYaw = (yaw + 180) % 360;
        const normalizedPitch = pitch + 90;

        // Calculate image coordinates
        const x = (normalizedYaw / 360) * panoramaWidth;
        const y = (normalizedPitch / 180) * panoramaHeight;

        return { x, y };
      }

      document.addEventListener("mouseup", async function (event) {
        try {
          // Get current view angles
          console.log("Mouse Up called");
          const pitch = await viewer.getPitch();
          const yaw = await viewer.getYaw();
          console.log("Pitch : ", pitch);
          console.log("Yaw : ", yaw);

          // Calculate the tile coordinates based on the current view angles
          const tileWidth = 512; // Adjust based on your tile size
          const tileHeight = 512; // Adjust based on your tile size

          const coordinates = pitchYawToImageCoordinates(pitch, yaw);
          console.log(coordinates);

          processTile(
            coordinates.x,
            coordinates.y,
            tileWidth,
            tileHeight,
            pitch,
            yaw
          );
        } catch (error) {
          console.error("Error in mouseup event:", error);
        }
      });
    </script>
  </body>
</html>
